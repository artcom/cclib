#include "texture.h"
#include <gl/pixelstoragemodes.h>
#include <gl/graphics.h>

using namespace cclib;

TextureAttributesPtr
TextureAttributes::create(int theNumberOfBits, int theNumberOfChannels) {
    TextureAttributesPtr myTextureAttributes = TextureAttributesPtr(new TextureAttributes());
    
    myTextureAttributes->type = GL_FLOAT;
    myTextureAttributes->wrapS = GL_CLAMP;
    myTextureAttributes->wrapT = GL_CLAMP;
    myTextureAttributes->filter = GL_NEAREST;
    
    bool is16Bit;
    
    switch(theNumberOfBits) {
        case 16:
            is16Bit = true;
            break;
        case 32:
            is16Bit = false;
            break;
        default:
            throw new cclib::Exception("The given number of bits is not supported. You can only create shader textures with 16 or 32 bit resolution.");
    }
    
    std::string vendorString = std::string(reinterpret_cast<const char*>(glGetString(GL_VENDOR)));
    unsigned nvVendorIndex = vendorString.find(std::string("NVIDIA"));
    bool isNvidia = (nvVendorIndex != std::string::npos);
    
    GLenum format;
    GLenum internalFormat;
    
    switch(theNumberOfChannels) {
        case 1:
            if(isNvidia) {
                internalFormat = is16Bit ? GL_FLOAT_R16_NV : GL_FLOAT_R32_NV;
            } else {
                internalFormat = is16Bit ? GL_LUMINANCE_FLOAT16_ATI : GL_LUMINANCE_FLOAT32_ATI;
            }
            format = GL_LUMINANCE;
            break;
        case 2:
            if(isNvidia) {
                internalFormat = is16Bit ? GL_FLOAT_RG16_NV : GL_FLOAT_RG32_NV;
            } else {
                internalFormat = is16Bit ? GL_LUMINANCE_ALPHA_FLOAT16_ATI : GL_LUMINANCE_ALPHA_FLOAT32_ATI;
            }
            format = GL_LUMINANCE_ALPHA;
            break;
        case 3:
            internalFormat = is16Bit ? GL_RGB16F : GL_RGB32F;
            format = GL_RGB;
            break;
        case 4:
            internalFormat = is16Bit ? GL_RGBA16F : GL_RGBA32F;
            format = GL_RGBA;
            break;
        default:
            throw new cclib::Exception("The given number of channels is not supported. You can only create shader textures with 1,2,3 or 4 channels.");
            
    }
    
    myTextureAttributes->internalFormat = internalFormat;
    myTextureAttributes->format = format;
    
    return myTextureAttributes;
}


TexturePtr
Texture::createTexture(GLuint target, TextureAttributesPtr attributes, unsigned int numberOfTextures)
{
    TexturePtr texture = TexturePtr(new Texture(target, attributes, numberOfTextures));
    return texture;
}

Texture::Texture(GLenum target, TextureAttributesPtr attributes, unsigned int numberOfTextures)
    : _target(target), _environmentMode(GL_MODULATE), _textureID(0),
      _internalFormat(attributes->internalFormat), _format(attributes->format),
      _width(0), _height(0), _depth(1),
      _pixelType(attributes->type), _isCompressed(false), _estimatedMemorySize(0),
      _textureMipmapFilter(GL_LINEAR_MIPMAP_LINEAR), _textureFilter(GL_NEAREST_MIPMAP_NEAREST)
{
    _textureIDs = createTextureIds(numberOfTextures);
    Graphics::checkError();
    
    // set attributes
    textureFilter(attributes->filter);
    Graphics::checkError();
    
    wrapS(attributes->wrapS);
    Graphics::checkError();

    wrapT(attributes->wrapT);
    Graphics::checkError();

    generateMipmaps(attributes->generateMipmaps);
}

/**
 * Sets whether mipmaps should be generated for the texture data. 
 * @param theGenerateMipmaps indicates whether mipmaps should be autogenerated for the resulting texture. 
 * 		  Currently if generateMipmaps is true then dataIsCompressed may not be true.
 */
void 
Texture::generateMipmaps(const bool & generateMipmaps) {
    _generateMipmaps = generateMipmaps;
    _hasMipmaps = generateMipmaps;
    _storageModes = PixelStorageModesPtr(new PixelStorageModes());
    _storageModes->alignment(1);

    if(generateMipmaps) {
        glGenerateMipmap(_target);
    }
}

/** 
 * Returns whether mipmaps should be generated for the texture data. 
 **/
bool & 
Texture::generateMipmaps() {
    return _generateMipmaps;
}
	
/**
 * Returns whether the data of this texture is compressed.
 * @return <code>true</code> if the texture is compressed
 */
bool & 
Texture::isCompressed() {
    return _isCompressed;
}
	
/**
 * Sets or resets the data for the texture. Be aware that this method is quiet
 * expensive. It should only be called for initialization or to totally reset a texture,
 * meaning to also change its size.
 * @param theData texture information
 */
// void 
// Texture::data(CCTextureData data) {
//     _mustFlipVertically = data.mustFlipVertically();
// 
//     _internalFormat = data.internalFormat();
//     _format = data.pixelFormat();
//     _pixelType = data.pixelType();
//     _storageModes = data.pixelStorageModes();
// 
//     _width = data.width();
//     _height = data.height();
// 
//     bind();
// 
//     data.pixelStorageModes().unpackStorage();
//     dataImplementation(data);
//     data.pixelStorageModes().defaultUnpackStorage();
// 
//     textureFilter(GL_LINEAR);
// 
//     if(generateMipmaps) {
//         generateMipmaps();
//     }
// }
	
/**
 * Returns a texture image into img. 
 * @param theLevel specifies the level-of-detail number of the desired image
 * @return data of the texture
 */
// ByteBuffer dataBuffer(int theLevel) {
//     GL2 gl = CCGraphics.currentGL();
//     size();
//     ByteBuffer myBuffer = ByteBuffer.allocate(size() * _myPixelType.bytesPerChannel * 4);
//     gl.glGetTexImage(_target, theLevel, _myFormat, _myPixelType, myBuffer);
//     myBuffer.rewind();
//     return myBuffer;
// }
	
/**
 * Sets or resets the data for the texture. Different from the normal data method, calling
 * <code>compressData()</code> uses OPENGLs internal texture compression. As a result textures
 * use far less memory on the graphics card. Dependent on the texture data's internal pixel 
 * format this method might fail. To check if texture compression was successful this method
 * returns a boolean value which is <code>true</code> in case that the compression was successful
 * or <code>false</code> otherwise. Be aware that this method is quiet
 * expensive. It should only be called for initialization or to totally reset a texture,
 * meaning to also change its size.
 * @param theData texture information
 * @param theHint specify whether texture compression uses the fastest or highest quality algorithm
 * @return <code>true</code> in case that the compression was successful or <code>false</code> otherwise
 */
// boolean compressData(final CCTextureCompressionHint theHint, final CCTextureData theData) {
//     _myMustFlipVertically = theData.mustFlipVertically();
// 
//     _myWidth = theData.width();
//     _myHeight = theData.height();
// 
//     _myInternalFormat = theData.internalFormat();
//     _myFormat = theData.pixelFormat();
// 
//     switch(_myInternalFormat) {
//         case RGB:
//         case RGB4:
//         case RGB5:
//         case RGB8:
//         case RGB10:
//         case RGB12:
//         case RGB16:
//             _myInternalFormat = CCPixelInternalFormat.COMPRESSED_RGB;
//             break;
//         case RGBA:
//         case RGBA2:
//         case RGBA4:
//         case RGBA8:
//         case RGBA12:
//         case RGBA16:
//         case RGB5_A1:
//         case RGB10_A2:
//             _myInternalFormat = CCPixelInternalFormat.COMPRESSED_RGBA;
//             break;
//     }
// 
//     bind();
//     GL2 gl = CCGraphics.currentGL();
//     gl.glHint(GL2.GL_TEXTURE_COMPRESSION_HINT, theHint);
//     theData.pixelStorageModes().unpackStorage();
//     switch(_target) {
//         case TEXTURE_1D:
//             gl.glTexImage1D(
//                     _target, 0, _myInternalFormat,
//                     theData.width(), 0, 
//                     theData.pixelFormat(), theData.pixelType(), theData.buffer()
//                     );
//             break;
//         case TEXTURE_2D:
//         case TEXTURE_RECT:
//             gl.glTexImage2D(
//                     _target, 0, _myInternalFormat, 
//                     theData.width(), theData.height(), 0, 
//                     theData.pixelFormat(), theData.pixelType(), theData.buffer()
//                     );
//             break;
//     }
//     theData.pixelStorageModes().defaultUnpackStorage();
// 
//     textureFilter(CCTextureFilter.LINEAR);
// 
//     if(_myGenerateMipmaps)gl.glGenerateMipmap(_target);
// 
//     int[] myData = new int[1];
// 
//     gl.glGetTexLevelParameteriv(_target, 0, GL2.GL_TEXTURE_COMPRESSED, myData, 0);
// 
//     boolean myResult = myData[0] > 0;
// 
//     if(myResult) {
//         gl.glGetTexLevelParameteriv(_target, 0, GL2.GL_TEXTURE_COMPRESSED_IMAGE_SIZE, myData, 0);
//         _myEstimatedMemorySize = myData[0];
//         gl.glGetTexLevelParameteriv(_target, 0, GL2.GL_TEXTURE_INTERNAL_FORMAT, myData, 0);
//     }
// 
//     return myResult;
// }
	
// 	boolean compressData(final CCTextureData theData) {
// 		return compressData(CCTextureCompressionHint.DONT_CARE, theData);
// 	}
	
std::vector<GLuint> 
Texture::createTextureIds(const unsigned int & numberOfIds) {
    std::vector<GLuint> textureIds = std::vector<GLuint>(numberOfIds, 0);
    glGenTextures(numberOfIds, &(textureIds[0]));
    
    return textureIds;
}
	
void 
Texture::bind() {
    bind(_textureID);
}
	
void 
Texture::bind(int id) {
    glBindTexture(_target, _textureIDs[id]);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, _environmentMode);
    Graphics::checkError();
    

    // if(_environmentMode == GL_BLEND) {
    //     glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, _blendColor.array(), 0);
    // }
}
	
void 
Texture::unbind() {
    glBindTexture(_target, 0);
    Graphics::checkError();
    
}

int 
Texture::id() {
    return _textureIDs[_textureID];
}

int 
Texture::id(const int & level) {
    return _textureIDs[level];
}

Texture::~Texture() {
    std::cout << "~Texture" << std::endl;
    glDeleteTextures(_textureIDs.size(), &(_textureIDs[0]));
}

/**
 * Returns the target of the texture can be 1D, 2D, 3D, RECT and CUBEMAP.
 * @return target of the texture
 */
GLenum
Texture::target() {
    return _target;
}

/**
 * Indicates whether the texture coordinates must be flipped vertically in 
 * order to properly display the texture. This is handled automatically by 
 * {@link CCGraphics#texture(cc.creativecomputing.graphics.texture.CCAbstractTexture) texture()} in
 * {@link CCGraphics} by setting a texture transform, but applications may generate or otherwise
 * produce texture coordinates which must be corrected.
 *
 * @return
 */
bool 
Texture::mustFlipVertically() {
    return _mustFlipVertically;
}

/**
 * Indicates whether the texture coordinates must be flipped vertically in 
 * order to properly display the texture. This is handled automatically by 
 * {@link CCGraphics#texture(cc.creativecomputing.graphics.texture.CCAbstractTexture) texture()} in
 * {@link CCGraphics} by setting a texture transform, but applications may generate or otherwise
 * produce texture coordinates which must be corrected.
 *
 * @param theMustFlipVertically true if the texture must be flipped otherwise false
 */
void 
Texture::mustFlipVertically(bool mustFlipVertically) {
    _mustFlipVertically = mustFlipVertically;
}

/** 
 * Returns the width of the texture.
 *
 * @return the width of the texture
 */
unsigned int 
Texture::width() {
    return _width;
}

/**
 * Returns the height of the texture. For 1D textures
 * this value is 1.
 *
 * @return the height of the texture
 */
unsigned int 
Texture::height() {
    return _height;
}

/**
 * Returns the number of pixels of this texture.
 * @return the number of pixels
 */
unsigned int 
Texture::size() {
    return _width * _height * _depth;
}

/**
 * Returns the size of the texture in pixels
 * @return
 */
Vector2iPtr
Texture::dimension() {
    return Vector2iPtr(new Vector2i(width(), height()));
}

/**
 * Returns the depth of the texture. This makes only 
 * sense for 3D texture. For all others this value is 1.
 * 
 * @return the depth of the texture
 */
int 
Texture::depth() {
    return _depth;
}

int 
Texture::border() {
    return 0;
}

/**
 * 
 * @return
 */
GLenum 
Texture::format() {
    return _format;
}

/**
 * 
 * @return
 */
GLenum 
Texture::internalFormat() {
    return _internalFormat;
}

GLenum 
Texture::pixelType() {
    return _pixelType;
}

/**
 * Shortcut to set a texture parameter only used internally
 * @param theType the parameter type we want to change
 * @param theValue the value for the parameter
 */
void 
Texture::parameter(GLenum type, GLint value) {
    if(_textureIDs.empty()) {
        return;
    }
    
    for(int i = 0; i < _textureIDs.size(); i++) {
        bind(i);
        Graphics::checkError();
        
        glTexParameteri((GLenum)_target, type, value);
        Graphics::checkError();
    }
}

/**
 * Shortcut to set a texture parameter only used internally
 * @param theType the parameter type we want to change
 * @param theValue the value for the parameter
 */
// protected 
void 
Texture::parameter(GLenum type, GLfloat value) {
    for(int i = 0; i < _textureIDs.size(); i++) {
        bind(i);
        glTexParameterf(_target, type, value);
    }
}


/**
 * Shortcut to set a texture parameter only used internally
 * @param theType the parameter type we want to change
 * @param theValue the value for the parameter
 */
// protected
void 
Texture::parameter(GLenum type, std::vector<GLfloat> values) {
    for(int i = 0; i < _textureIDs.size();i++) {
        bind(i);
        glTexParameterfv(_target, type, &(values[0]));
    }
}
	
/**
 * Shortcut to get a texture parameter
 * @param theGLID the gl id of the parameter to get
 * @return the value for the given parameter
 */
int 
Texture::parameter(int glid) {
    int result;
    glGetTexLevelParameteriv(_target, 0, glid, &(result));
    return result;
}

/**
 * Normally, you specify texture coordinates between 0.0 and 1.0 to map out a texture. 
 * If texture coordinates fall outside this range, OpenGL handles them according to the 
 * current texture wrapping mode. Using this method you can set the wrap mode for each coordinate 
 * individually. The wrap mode can then be set to one of the following values:
 * <ul>
 * <li>{@link CCTextureWrap#REPEAT} simply causes the texture to repeat in the direction in which the texture 
 * coordinate has exceeded the image boundary. The texture repeats again for every multiple
 * of the texture size. This mode is very useful for applying a small tiled texture to large 
 * geometric surfaces. Well-done seamless textures can lend the appearance of a seemingly much 
 * larger texture, but at the cost of a much smaller texture image.</li>
 * <li>{@link CCTextureWrap#MIRRORED_REPEAT} works like {@link CCTextureWrap#REPEAT} but mirrors 
 * the texture for more seamless results on repeating the texture</li>
 * <li>{@link CCTextureWrap#CLAMP} clamps the texture if you use values going over the image range. The needed
 * texels are taken from the texture border.
 * results on repeating the texture</li>
 * <li>{@link CCTextureWrap#CLAMP_TO_EDGE} simply ignores texel samples that go over the edge and does not include them in the average</li>
 * <li>{@link CCTextureWrap#CLAMP_TO_BORDER} uses only border texels whenever the texture coordinates fall outside the of the texture.</li>
 * </ul>
 * @param theTextureWrap mode for texture wrapping 
 */
void 
Texture::wrap(GLenum textureWrap){
    parameter(GL_TEXTURE_WRAP_R, (int)textureWrap);
    parameter(GL_TEXTURE_WRAP_S, (int)textureWrap);
    parameter(GL_TEXTURE_WRAP_T, (int)textureWrap);
}

void 
Texture::wrapR(GLenum textureWrap){
    parameter(GL_TEXTURE_WRAP_R, (int)textureWrap);
}

/**
 * Sets the horizontal wrapping behavior when a texture coordinate falls outside the range of [0,1].
 * @see #wrap(CCTextureWrap)
 * @param theTextureWrap
 */
void 
Texture::wrapS(GLenum textureWrap){
    parameter(GL_TEXTURE_WRAP_S, (int)textureWrap);
}

/**
 * 
 * @param theTextureWrap
 */
void 
Texture::wrapT(GLenum textureWrap) {
    parameter(GL_TEXTURE_WRAP_T, (GLint)textureWrap);
}

// void 
// Texture::textureBorderColor(CCColor theColor) {
//     parameter(GL_TEXTURE_BORDER_COLOR, theColor.array());
// }
	
void 
Texture::updateFilter() {
    // set mag filter first as this has no impact on mipmapping
    parameter(GL_TEXTURE_MAG_FILTER, (GLint)_textureFilter);

    if(!_hasMipmaps) {
        parameter(GL_TEXTURE_MIN_FILTER, (GLint)_textureFilter);
        return;
    }

#warning caused an error.
#if 0
    if(_textureFilter == GL_NEAREST) {
        if(_textureMipmapFilter == GL_NEAREST) {
            parameter(GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
        }else {
            parameter(GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);
        }
    }else {
        if(_textureMipmapFilter == GL_NEAREST) {
            parameter(GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);
        }else {
            parameter(GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        }
    }
    
#else
    if(_textureMipmapFilter == GL_NEAREST) {
        parameter(GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    }else {
        parameter(GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    }
#endif
}

/**
 * Applies anisotropic filtering to the texture. THis is helpful to avoid
 * blurring in more oblique angle of the geometry to the view. You have to 
 * provide an amount between 0 and 1 be aware that the maximum amount of filtering
 * is dependent on the current hardware. So 0 stands for no anisotropic filtering
 * 1 for the maximum available amount.
 * @param theAmount the amount of filtering number between 0 and 1
 */
void 
Texture::anisotropicFiltering(float amount) {
//     parameter(GL_TEXTURE_MAX_ANISOTROPY_EXT, 
//         CCMath.blend(1, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, amount));
}

/**
 * <p>
 * The texture filter function is used whenever the pixel being textured
 * maps to an area greater or smaller than one texture element. There are two 
 * defined filter functions. 
 * <ul>
 * <li>{@link CCTextureFilter#NEAREST} uses the nearest pixel</li>
 * <li>{@link CCTextureFilter#LINEAR} uses the nearest four texture elements to compute the texture value.</li>
 * </ul>
 * </p>
 * The default is {@link CCTextureFilter#LINEAR}.       
 * @param theFilter
 */
void 
Texture::textureFilter(GLenum filter){
    _textureFilter = filter;
    updateFilter();
}

/**
 * <p>
 * The texture mipmap filter function is used whenever the pixel being textured
 * maps to an area greater or smaller than one texture element and mipmap data is defined. 
 * </p>
 * <p>A mipmap is an ordered set of arrays representing the same image at 
 * progressively lower resolutions. If the texture has dimensions 2n x 2m,
 * there are max(n,m) + 1 mipmaps.</p>
 * <ul>
 * <li><code>NEAREST</code> uses the nearest mipmap</li>
 * <li><code>LINEAR</code> uses the nearest two mipmaps to compute the texture value.</li>
 * </ul>
 * The default is <code>NEAREST</code>.
 *              
 * @param theFilter
 */
void 
Texture::textureMipmapFilter(GLenum filter){
    _textureMipmapFilter = filter;
    updateFilter();
}

/**
 * Defines how colors from the texels are combined with the color of the
 * underlying geometry.
 * @param theMode
 */
void 
Texture::textureEnvironmentMode(GLenum mode) {
    _environmentMode = mode;
}

/**
 * Specifies a single symbolic constant indicating how depth values should be 
 * treated during filtering and texture application.
 * @param theMode
 */
void 
Texture::depthTextureMode(GLenum mode) {
    parameter(GL_DEPTH_TEXTURE_MODE, (int)mode);
}

// /**
//  * Textures can also be blended with a constant blending color using the 
//  * <code>BLEND</code> texture environment mode. If you set this environment mode, 
//  * you must also set the texture environment color with this method.
//  * @param theBlendColor blend color for the blend mode
//  */
// void 
// Texture::blendColor(CCColor blendColor) {
//     _blendColor = blendColor;
// }

void
Texture::data(const std::vector<unsigned char> & theData) {
    data(theData, _width, _height);
}

void
Texture::data(const std::vector<unsigned char> & theData, unsigned int theWidth, unsigned int theHeight) {
    _mustFlipVertically = false;
    
    _internalFormat = GL_RGBA;
    _format = GL_RGBA;
    _pixelType = GL_UNSIGNED_BYTE;
    _storageModes = PixelStorageModesPtr(new PixelStorageModes());
    
    _width = theWidth;
    _height = theHeight;
    
    bind();

    _storageModes->unpackStorage();
    dataImplementation(theData);
    _storageModes->defaultUnpackStorage();
    
    textureFilter(GL_LINEAR);
    
    if(_generateMipmaps) {
        glGenerateMipmap(_target);
    }
}

