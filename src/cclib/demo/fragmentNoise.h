const char * simplexnoisefragment_fp = 
    "uniform float noiseScale = 1;\n"
    "uniform float3 noiseOffset = float3(0,0,0);\n"
    "void main(\n"
    "	in  float2 coords : WPOS,\n"
    "	out float4 output0 : COLOR0\n"
    ") { \n"
    "	output0 = (snoise(float3(coords.xy,0) * 0.01 * noiseScale + noiseOffset) + 1)/2;\n"
    "}\n";

const char * simplex_fp = 
    "uniform sampler2D 	permTexture;\n"
    "uniform sampler1D 	simplexTexture;\n"
    "uniform sampler2D 	gradTexture;\n"
    "uniform float 		time;\n"
    "\n"
    "uniform int octaves = 4;\n"
    "uniform float falloff = 0.5;\n"
    "\n"
    "#define ONE 0.00390625\n"
    "#define ONEHALF 0.001953125\n"
    "\n"
    "// Skew and unskew factors are a bit hairy for 2D, so define them as constants\n"
    "// This is (sqrt(3.0)-1.0)/2.0\n"
    "#define F2 0.366025403784\n"
    "// This is (3.0-sqrt(3.0))/6.0\n"
    "#define G2 0.211324865405\n"
    "\n"
    "\n"
    "// The skewing and unskewing factors are much simpler for the 3D case\n"
    "#define F3 0.333333333333\n"
    "#define G3 0.166666666667\n"
    "\n"
    "// The skewing and unskewing factors are hairy again for the 4D case\n"
    "// This is (sqrt(5.0)-1.0)/4.0\n"
    "#define F4 0.309016994375\n"
    "	\n"
    "// This is (5.0-sqrt(5.0))/20.0\n"
    "#define G4 0.138196601125\n"
    "\n"
    "/*\n"
    " * 2D simplex noise. Somewhat slower but much better looking than classic noise.\n"
    " */\n"
    "float snoise(float2 P) {\n"
    "	// Skew the (x,y) space to determine which cell of 2 simplices we're in\n"
    "	float s = (P.x + P.y) * F2;   // Hairy factor for 2D skewing\n"
    "	float2 Pi = floor(P + s);\n"
    "	float t = (Pi.x + Pi.y) * G2; // Hairy factor for unskewing\n"
    "	float2 P0 = Pi - t; // Unskew the cell origin back to (x,y) space\n"
    "	Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n"
    "\n"
    "	float2 Pf0 = P - P0;  // The x,y distances from the cell origin\n"
    "\n"
    "	// For the 2D case, the simplex shape is an equilateral triangle.\n"
    "	// Find out whether we are above or below the x=y diagonal to\n"
    "	// determine which of the two triangles we're in.\n"
    "	float2 o1;\n"
    "	if(Pf0.x > Pf0.y) o1 = float2(1.0, 0.0);  // +x, +y traversal order\n"
    "	else o1 = float2(0.0, 1.0);               // +y, +x traversal order\n"
    "\n"
    "	// Noise contribution from simplex origin\n"
    "	float2 grad0 = tex2D(permTexture, Pi).rg * 4.0 - 1.0;\n"
    "	float t0 = 0.5 - dot(Pf0, Pf0);\n"
    "	float n0;\n"
    "	\n"
    "	if (t0 < 0.0) n0 = 0.0;\n"
    "	else {\n"
    "		t0 *= t0;\n"
    "		n0 = t0 * t0 * dot(grad0, Pf0);\n"
    "	}\n"
    "\n"
    "	// Noise contribution from middle corner\n"
    "	float2 Pf1 = Pf0 - o1 + G2;\n"
    "	float2 grad1 = tex2D(permTexture, Pi + o1*ONE).rg * 4.0 - 1.0;\n"
    "	float t1 = 0.5 - dot(Pf1, Pf1);\n"
    "	float n1;\n"
    "	if (t1 < 0.0) n1 = 0.0;\n"
    "	else {\n"
    "		t1 *= t1;\n"
    "		n1 = t1 * t1 * dot(grad1, Pf1);\n"
    "	}\n"
    "  \n"
    "	// Noise contribution from last corner\n"
    "	float2 Pf2 = Pf0 - float2(1.0-2.0*G2);\n"
    "	float2 grad2 = tex2D(permTexture, Pi + float2(ONE, ONE)).rg * 4.0 - 1.0;\n"
    "	float t2 = 0.5 - dot(Pf2, Pf2);\n"
    "	float n2;\n"
    "	if(t2 < 0.0) n2 = 0.0;\n"
    "	else {\n"
    "		t2 *= t2;\n"
    "		n2 = t2 * t2 * dot(grad2, Pf2);\n"
    "	}\n"
    "	\n"
    "	// Sum up and scale the result to cover the range [-1,1]\n"
    "	return 70.0 * (n0 + n1 + n2);\n"
    "}\n"
    "\n"
    "float noise(float2 P){\n"
    "	float result = 0;\n"
    "	float scale = 1;\n"
    "	float fall = 1 - falloff;\n"
    "	\n"
    "	for(int i = 0; i < octaves;i++){\n"
    "		result += snoise(P * scale) * fall;\n"
    "		scale *= 2;\n"
    "		fall *= falloff;\n"
    "	}\n"
    "	\n"
    "	return result;\n"
    "}\n"
    "\n"
    "\n"
    "/*\n"
    " * 3D simplex noise. Comparable in speed to classic noise, better looking.\n"
    " */\n"
    "float snoise(float3 P) {\n"
    "	// Skew the (x,y,z) space to determine which cell of 6 simplices we're in\n"
    "	float s = (P.x + P.y + P.z) * F3; // Factor for 3D skewing\n"
    "	float3 Pi = floor(P + s);\n"
    "	float t = (Pi.x + Pi.y + Pi.z) * G3;\n"
    "	float3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space\n"
    "	Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n"
    "\n"
    "	float3 Pf0 = P - P0;// The x,y distances from the cell origin\n"
    "\n"
    "	// For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n"
    "	// To find out which of the six possible tetrahedra we're in, we need to\n"
    "	// determine the magnitude ordering of x, y and z components of Pf0.\n"
    "	// The method below is explained briefly in the C code. It uses a small\n"
    "	// 1D texture as a lookup table. The table is designed to work for both\n"
    "	// 3D and 4D noise, so only 8 (only 6, actually) of the 64 indices are\n"
    "	// used here.\n"
    "	float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n"
    "	float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n"
    "	float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n"
    "	float sindex = c1 + c2 + c3;\n"
    "	float3 offsets = tex1D(simplexTexture, sindex).xyz;\n"
    "	float3 o1 = step(0.375, offsets);\n"
    "	float3 o2 = step(0.125, offsets);\n"
    "\n"
    "	// Noise contribution from simplex origin\n"
    "	float perm0 = tex2D(permTexture, Pi.xy).w;\n"
    "	float3  grad0 = tex2D(permTexture, float2(perm0, Pi.z)).xyz * 4.0 - 1.0;\n"
    "	float t0 = 0.6 - dot(Pf0, Pf0);\n"
    "	float n0;\n"
    "	if (t0 < 0.0) n0 = 0.0;\n"
    "	else {\n"
    "		t0 *= t0;\n"
    "		n0 = t0 * t0 * dot(grad0, Pf0);\n"
    "	}\n"
    "\n"
    "	// Noise contribution from second corner\n"
    "	float3 Pf1 = Pf0 - o1 + G3;\n"
    "	float perm1 = tex2D(permTexture, Pi.xy + o1.xy*ONE).w;\n"
    "	float3  grad1 = tex2D(permTexture, float2(perm1, Pi.z + o1.z*ONE)).xyz * 4.0 - 1.0;\n"
    "	float t1 = 0.6 - dot(Pf1, Pf1);\n"
    "	float n1;\n"
    "	if (t1 < 0.0) n1 = 0.0;\n"
    "	else {\n"
    "		t1 *= t1;\n"
    "		n1 = t1 * t1 * dot(grad1, Pf1);\n"
    "	}\n"
    "\n"
    "	// Noise contribution from third corner\n"
    "	float3 Pf2 = Pf0 - o2 + 2.0 * G3;\n"
    "	float perm2 = tex2D(permTexture, Pi.xy + o2.xy*ONE).w;\n"
    "	float3  grad2 = tex2D(permTexture, float2(perm2, Pi.z + o2.z*ONE)).xyz * 4.0 - 1.0;\n"
    "	float t2 = 0.6 - dot(Pf2, Pf2);\n"
    "	float n2;\n"
    "	\n"
    "	if (t2 < 0.0) n2 = 0.0;\n"
    "	else {\n"
    "		t2 *= t2;\n"
    "		n2 = t2 * t2 * dot(grad2, Pf2);\n"
    "	}\n"
    "\n"
    "	// Noise contribution from last corner\n"
    "	float3 Pf3 = Pf0 - float3(1.0-3.0*G3);\n"
    "	float perm3 = tex2D(permTexture, Pi.xy + float2(ONE, ONE)).w;\n"
    "	float3  grad3 = tex2D(permTexture, float2(perm3, Pi.z + ONE)).xyz * 4.0 - 1.0;\n"
    "	float t3 = 0.6 - dot(Pf3, Pf3);\n"
    "	float n3;\n"
    "	if(t3 < 0.0) n3 = 0.0;\n"
    "	else {\n"
    "		t3 *= t3;\n"
    "		n3 = t3 * t3 * dot(grad3, Pf3);\n"
    "	}\n"
    "\n"
    "	// Sum up and scale the result to cover the range [-1,1]\n"
    "	return 32.0 * (n0 + n1 + n2 + n3);\n"
    "}\n"
    "\n"
    "float noise(float3 P){\n"
    "	float result = 0;\n"
    "	float scale = 1;\n"
    "	float fall = falloff;\n"
    "	\n"
    "	for(int i = 0; i < octaves;i++){\n"
    "		result += snoise(P * scale) * fall;\n"
    "		scale *= 2;\n"
    "		fall *= falloff;\n"
    "	}\n"
    "	\n"
    "	return result;\n"
    "}\n"
    "\n"
    "/*\n"
    " * 4D simplex noise. A lot faster than classic 4D noise, and better looking.\n"
    " */\n"
    "float snoise(float4 P){\n"
    "\n"
    "	// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n"
    " 	float s = (P.x + P.y + P.z + P.w) * F4; // Factor for 4D skewing\n"
    "	float4 Pi = floor(P + s);\n"
    "	float t = (Pi.x + Pi.y + Pi.z + Pi.w) * G4;\n"
    "	float4 P0 = Pi - t; // Unskew the cell origin back to (x,y,z,w) space\n"
    "	Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n"
    "\n"
    "	float4 Pf0 = P - P0;  // The x,y distances from the cell origin\n"
    "\n"
    "	// For the 4D case, the simplex is a 4D shape I won't even try to describe.\n"
    "	// To find out which of the 24 possible simplices we're in, we need to\n"
    "	// determine the magnitude ordering of x, y, z and w components of Pf0.\n"
    "	// The method below is presented without explanation. It uses a small 1D\n"
    "	// texture as a lookup table. The table is designed to work for both\n"
    "	// 3D and 4D noise and contains 64 indices, of which only 24 are actually\n"
    "	// used. An extension to 5D would require a larger texture here.\n"
    "	float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n"
    "	float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n"
    "	float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n"
    "	float c4 = (Pf0.x > Pf0.w) ? 0.0625 : 0.0;\n"
    "	float c5 = (Pf0.y > Pf0.w) ? 0.03125 : 0.0;\n"
    "	float c6 = (Pf0.z > Pf0.w) ? 0.015625 : 0.0;\n"
    "	float sindex = c1 + c2 + c3 + c4 + c5 + c6;\n"
    "	float4 offsets = tex1D(simplexTexture, sindex).xyzw;\n"
    "	\n"
    "	float4 o1 = step(0.625, offsets);\n"
    "	float4 o2 = step(0.375, offsets);\n"
    "	float4 o3 = step(0.125, offsets);\n"
    "	\n"
    "	// Noise contribution from simplex origin\n"
    "	float perm0xy = tex2D(permTexture, Pi.xy).w;\n"
    "	float perm0zw = tex2D(permTexture, Pi.zw).w;\n"
    "	\n"
    "	float4  grad0 = tex2D(gradTexture, float2(perm0xy, perm0zw)).xyzw * 4.0 - 1.0;\n"
    "	float t0 = 0.6 - dot(Pf0, Pf0);\n"
    "	float n0;\n"
    "  \n"
    "  	if (t0 < 0.0) n0 = 0.0;\n"
    "  	else {\n"
    "		t0 *= t0;\n"
    "		n0 = t0 * t0 * dot(grad0, Pf0);\n"
    "	}\n"
    "\n"
    "	// Noise contribution from second corner\n"
    "	float4 Pf1 = Pf0 - o1 + G4;\n"
    "	o1 = o1 * ONE;\n"
    "	float perm1xy = tex2D(permTexture, Pi.xy + o1.xy).w;\n"
    "	float perm1zw = tex2D(permTexture, Pi.zw + o1.zw).w;\n"
    "	float4  grad1 = tex2D(gradTexture, float2(perm1xy, perm1zw)).xyzw * 4.0 - 1.0;\n"
    "	float t1 = 0.6 - dot(Pf1, Pf1);\n"
    "	float n1;\n"
    "\n"
    "	if (t1 < 0.0) n1 = 0.0;\n"
    "	else {\n"
    " 		t1 *= t1;\n"
    " 		n1 = t1 * t1 * dot(grad1, Pf1);\n"
    "	}\n"
    "\n"
    "	// Noise contribution from third corner\n"
    "	float4 Pf2 = Pf0 - o2 + 2.0 * G4;\n"
    "	o2 = o2 * ONE;\n"
    "	float perm2xy = tex2D(permTexture, Pi.xy + o2.xy).w;\n"
    "	float perm2zw = tex2D(permTexture, Pi.zw + o2.zw).w;\n"
    "	float4  grad2 = tex2D(gradTexture, float2(perm2xy, perm2zw)).xyzw * 4.0 - 1.0;\n"
    "	float t2 = 0.6 - dot(Pf2, Pf2);\n"
    "	float n2;\n"
    "	\n"
    "	if (t2 < 0.0) n2 = 0.0;\n"
    "	else {\n"
    "		t2 *= t2;\n"
    "		n2 = t2 * t2 * dot(grad2, Pf2);\n"
    "	}\n"
    "	\n"
    "	// Noise contribution from fourth corner\n"
    "	float4 Pf3 = Pf0 - o3 + 3.0 * G4;\n"
    "	o3 = o3 * ONE;\n"
    "	float perm3xy = tex2D(permTexture, Pi.xy + o3.xy).w;\n"
    "	float perm3zw = tex2D(permTexture, Pi.zw + o3.zw).w;\n"
    "	float4  grad3 = tex2D(gradTexture, float2(perm3xy, perm3zw)).xyzw * 4.0 - 1.0;\n"
    "	float t3 = 0.6 - dot(Pf3, Pf3);\n"
    "	float n3;\n"
    "\n"
    "	if (t3 < 0.0) n3 = 0.0;\n"
    "	else {\n"
    "		t3 *= t3;\n"
    "		n3 = t3 * t3 * dot(grad3, Pf3);\n"
    "	}\n"
    "  \n"
    "	// Noise contribution from last corner\n"
    "	float4 Pf4 = Pf0 - float4(1.0-4.0*G4);\n"
    "	float perm4xy = tex2D(permTexture, Pi.xy + float2(ONE, ONE)).w;\n"
    "	float perm4zw = tex2D(permTexture, Pi.zw + float2(ONE, ONE)).w;\n"
    "	float4  grad4 = tex2D(gradTexture, float2(perm4xy, perm4zw)).xyzw * 4.0 - 1.0;\n"
    "	float t4 = 0.6 - dot(Pf4, Pf4);\n"
    "	float n4;\n"
    "\n"
    "	if(t4 < 0.0) n4 = 0.0;\n"
    "	else {\n"
    "		t4 *= t4;\n"
    "		n4 = t4 * t4 * dot(grad4, Pf4);\n"
    "	}\n"
    "\n"
    "	// Sum up and scale the result to cover the range [-1,1]\n"
    "	return 27.0 * (n0 + n1 + n2 + n3 + n4);\n"
    "}          \n";


