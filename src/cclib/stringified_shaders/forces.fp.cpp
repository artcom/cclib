/* Generated file, do not edit! */

#include "forces.fp.h"

char const* const forces_fp = 
   "uniform samplerRECT positionTexture;\n"
   "uniform samplerRECT velocityTexture;\n"
   "uniform samplerRECT infoTexture;\n"
   "interface Force{\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime);\n"
   "};\n"
   "struct Gravity : Force{\n"
   "	float3 gravity;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		return float3(gravity) * strength; \n"
   "	}\n"
   "};\n"
   "struct ViscousDrag : Force{\n"
   "	float coefficient;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		return theVelocity * theDeltaTime * -coefficient * strength; \n"
   "	}\n"
   "};\n"
   "struct Attractor : Force{\n"
   "	float3 position;\n"
   "	float strength;\n"
   "	float radius;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 force = position - thePosition;\n"
   "        float dist = length(force);\n"
   "		\n"
   "		if (dist < radius) {\n"
   "			float myFallOff = 1f - dist / radius;\n"
   "			float myForce = myFallOff * myFallOff * strength;\n"
   "			//force -= theVelocity;\n"
   "            force = force * myForce / dist;\n"
   "            return force;\n"
   "        } else {\n"
   "        	return float3(0,0,0);\n"
   "        }\n"
   "	}\n"
   "};\n"
   "/* \n"
   " * Force to move particles on a terrain\n"
   " */\n"
   "struct TerrainForce : Force{\n"
   "	float strength;\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	float2 textureSize;\n"
   "	float3 scale;\n"
   "	float3 offset;\n"
   "	\n"
   "	float exponent;\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 fPosition = thePosition + theVelocity * theDeltaTime;\n"
   "		\n"
   "		float2 terrainPos = fPosition.xz / scale.xz + offset.xz;\n"
   "		float height = texRECT(texture, terrainPos);\n"
   "			\n"
   "		float displacement = fPosition.y - height * scale.y + offset.y + theVelocity.y;\n"
   "		\n"
   "		return float3(0,clamp(-displacement,-1,1),0);\n"
   "	}\n"
   "};\n"
   "struct NoiseHeightmapForce : Force{\n"
   "	float noiseScale;\n"
   "	float strength;\n"
   "	float height;\n"
   "	float3 noiseOffset;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 fPosition = thePosition + theVelocity * theDeltaTime;\n"
   "		float3 noisePosition = (fPosition) * noiseScale + noiseOffset;\n"
   "		\n"
   "		float displacement =  fPosition.y - noise(noisePosition.xz) * height +  + theVelocity.y;\n"
   "		return float3(0,clamp(-displacement,-1,1),0) * strength;\n"
   "	}\n"
   "};\n"
   "struct NoiseForceField : Force{\n"
   "	float noiseScale;\n"
   "	float strength;\n"
   "	float3 noiseOffset;\n"
   "	\n"
   "	float noiseLengthScales[3];\n"
   "	float noiseGains[3];\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 noisePosition = (thePosition + theVelocity) * noiseScale + noiseOffset;\n"
   "		float3 result = float3(\n"
   "			snoise(noisePosition),\n"
   "			snoise(noisePosition+100),\n"
   "			snoise(noisePosition+200)\n"
   "		);\n"
   "		noisePosition = (thePosition + theVelocity) * noiseScale + noiseOffset.yzx;\n"
   "		result += float3(\n"
   "			snoise(noisePosition),\n"
   "			snoise(noisePosition+100),\n"
   "			snoise(noisePosition+200)\n"
   "		);\n"
   "		//result *= 50 * theDeltaTime;\n"
   "		return result * strength;\n"
   "	}\n"
   "};\n"
   "/*\n"
   "struct NoiseForceField : Force{\n"
   "	float noiseScale;\n"
   "	float strength;\n"
   "	float3 noiseOffset;\n"
   "	\n"
   "	float noiseLengthScales[3];\n"
   "	float noiseGains[3];\n"
   "	\n"
   "	float noise0(float3 p) {\n"
   "		return snoise(p);\n"
   "	}\n"
   "	float noise1(float3 p) {\n"
   "		return snoise(float3(p.y + 31.416, p.z - 47.853, p.x + 12.793));\n"
   "	}\n"
   "	float noise2(float3 p) {\n"
   "		return snoise(float3(p.z - 233.145, p.x - 113.408, p.y - 185.31));\n"
   "	}\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 noisePosition = (thePosition + theVelocity) * noiseScale + noiseOffset;\n"
   "		float3 result = float3(0,0,0);\n"
   "		\n"
   "		 //float d=distance_and_normal(x, y, z, normal);\n"
   "		// add turbulence octaves that respect boundaries, increasing upwards\n"
   "		for (int i = 0; i < noiseLengthScales.length; i++) {\n"
   "			result += float3(noise0(noisePosition), noise1(noisePosition), noise2(noisePosition)) * noiseGains[i];\n"
   "		}\n"
   "		return result * strength;\n"
   "	}\n"
   "};\n"
   "*/\n"
   "struct CurveForceFieldFollow : Force{\n"
   "	float strength;\n"
   "	float prediction;\n"
   "	\n"
   "	float radius;\n"
   "	\n"
   "	float offset;\n"
   "	float scale;\n"
   "	float outputScale;\n"
   "	\n"
   "	float3 curveAtPoint(float x){\n"
   "		float y = outputScale * (snoise(float2(x * scale + offset,0)));\n"
   "		float z = outputScale * (snoise(float2(x * scale + offset + 100, 0)));\n"
   "		return float3(x, y, z);\n"
   "	}\n"
   "	\n"
   "	float3 flowAtPoint(float3 position) {\n"
   "		float3 result = float3(0,0,0);\n"
   "		\n"
   "		float3 myCurvePoint = curveAtPoint(position.x);\n"
   "		float curveDistance = distance(myCurvePoint, position);\n"
   "		\n"
   "		if(curveDistance > radius * 2){\n"
   "			result = (myCurvePoint - position) / curveDistance;\n"
   "		\n"
   "		}else if(curveDistance > radius && curveDistance <= radius * 2){\n"
   "			float blend = (curveDistance - radius) / radius;\n"
   "			result = result * (1 - blend) + (myCurvePoint-position) / curveDistance * blend;\n"
   "		}\n"
   "	\n"
   "		return result;\n"
   "	}\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 futurePosition = thePosition + theVelocity * prediction;\n"
   "		float3 result = flowAtPoint(futurePosition) * strength;\n"
   "		return result;\n"
   "	}\n"
   "};\n"
   "/*\n"
   "///////////////////////////////\n"
   "//\n"
   "// SPHERE CURVE FORCE FIELD\n"
   "//\n"
   "///////////////////////////////\n"
   "struct NoiseSphereForceField : ForceField{\n"
   "	float noiseRadius;\n"
   "	float3 position;\n"
   "	\n"
   "	float3 flowAtPoint(float3 thePosition, float3 noiseOffset, float noiseScale) {\n"
   "		float3 noisePosition = thePosition * noiseScale + noiseOffset;\n"
   "		float3 result = float3(snoise(noisePosition), snoise(noisePosition+100), snoise(noisePosition+200));\n"
   "		\n"
   "		float sphereDistance = distance(position,thePosition);\n"
   "		\n"
   "		if(sphereDistance > noiseRadius * 2){\n"
   "			result = (position - thePosition) / sphereDistance;\n"
   "		}else if(sphereDistance > noiseRadius && sphereDistance <= noiseRadius * 2){\n"
   "			float blend = (sphereDistance - noiseRadius) / noiseRadius;\n"
   "			result = result * (1 - blend) + (position-thePosition) / sphereDistance * blend;\n"
   "		}\n"
   "	\n"
   "		\n"
   "		return result;\n"
   "	}\n"
   "};\n"
   "struct SphereForceFieldFollow : Force{\n"
   "	float noiseScale;\n"
   "	float strength;\n"
   "	float prediction;\n"
   "	float3 noiseOffset;\n"
   "	\n"
   "	NoiseSphereForceField noiseSphereField;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 noisePosition = (thePosition + normalize(theVelocity) * prediction);\n"
   "		float3 result = noiseSphereField.flowAtPoint(noisePosition, noiseOffset, noiseScale);\n"
   "		result *= 100 * theDeltaTime * strength;\n"
   "		return result;\n"
   "	}\n"
   "};*/\n"
   "struct TextureForceFieldXZ : Force{\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	float2 textureSize;\n"
   "	float2 textureScale;\n"
   "	float2 textureOffset;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float2 texturePos = thePosition.xz / textureScale.xy + textureOffset.xy;\n"
   "		float3 force = texRECT(texture, texturePos);\n"
   "		force *= 2;\n"
   "		force -= 1;\n"
   "		force.z = force.y;\n"
   "		force.y = 0;\n"
   "		\n"
   "		return force * strength;\n"
   "	}\n"
   "};\n"
   "struct TextureForceFieldXY : Force{\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	float2 textureSize;\n"
   "	float2 textureScale;\n"
   "	float2 textureOffset;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float2 texturePos = thePosition.xy / textureScale.xy + textureOffset.xy;\n"
   "		//texturePos.y = textureSize.y - texturePos.y;\n"
   "		float3 force = texRECT(texture, texturePos);\n"
   "		force *= 2;\n"
   "		force -= 1;\n"
   "		force.z = 0;\n"
   "		\n"
   "		return force * strength;\n"
   "	}\n"
   "};\n"
   "struct Texture3DForceField : Force{\n"
   "	sampler3D texture;\n"
   "	\n"
   "	float3 textureScale;\n"
   "	float3 textureOffset;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 texturePos = (thePosition - textureOffset) / textureScale;\n"
   "		float3 force = tex3D(texture, texturePos);\n"
   "		if(texturePos.x >= 1 || texturePos.y >= 1 || texturePos.z >= 1 || texturePos.x <= 0 || texturePos.y <= 0 || texturePos.z <= 0)force = float3(0,0,0);\n"
   "		return force * strength;\n"
   "	}\n"
   "};\n"
   "struct FluidForceField : Force{\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	float2 textureSize;\n"
   "	float2 textureScale;\n"
   "	float2 textureOffset;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float2 texturePos = thePosition.xy / textureScale.xy + textureOffset.xy;\n"
   "		//texturePos.y = textureSize.y - texturePos.y;\n"
   "		float3 force = texRECT(texture, texturePos);\n"
   "		force.z = 0;\n"
   "		\n"
   "		return force * strength;\n"
   "	}\n"
   "};\n"
   "struct ForceBlend : Force{\n"
   "	sampler2D texture;\n"
   "	\n"
   "	Force force1;\n"
   "	Force force2;\n"
   "	\n"
   "	float2 dimension;\n"
   "	\n"
   "	float strength;\n"
   "	float blend;\n"
   "	float minBlend;\n"
   "	float maxBlend;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float2 myTexID = theTexID / dimension;\n"
   "		float myBlend = tex2D(texture, myTexID).x;\n"
   "		myBlend = clamp(myBlend, 0, maxBlend);\n"
   "		myBlend *= step(1 - myBlend, 1 - minBlend);\n"
   "		return lerp(\n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			force2.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			myBlend * blend // * applyX * applyY\n"
   "		) * strength;\n"
   "	}\n"
   "};\n"
   "struct TextureForceBlend : Force{\n"
   "	samplerRECT texture;\n"
   "	float2 textureScale;\n"
   "	float2 textureOffset;\n"
   "	\n"
   "	Force force1;\n"
   "	Force force2;\n"
   "	\n"
   "	float strength;\n"
   "	float blend;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float2 texturePos = (thePosition.xy * float2(1,-1)) / textureScale + textureOffset.xy;\n"
   "		\n"
   "		return lerp(\n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			force2.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			texRECT(texture, texturePos).x * blend // * applyX * applyY\n"
   "		) * strength;\n"
   "	}\n"
   "};\n"
   "struct IDTextureForceBlend : Force{\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	Force force1;\n"
   "	Force force2;\n"
   "	\n"
   "	float strength;\n"
   "	float blend;\n"
   "	float power;\n"
   "	\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		return lerp(\n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			force2.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			texRECT(texture, theTexID).x * pow(blend,power) // * applyX * applyY\n"
   "		) * strength;\n"
   "	}\n"
   "};\n"
   "struct IDTextureBlendForce : Force{\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	Force force1;\n"
   "	\n"
   "	float strength;\n"
   "	float power;\n"
   "	\n"
   "	float blendRangeStart;\n"
   "	float blendRangeEnd;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float blend = texRECT(texture, theTexID).x;\n"
   "		blend = smoothstep(blendRangeStart, blendRangeEnd, blend);\n"
   "		return \n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime) *\n"
   "			texRECT(texture, theTexID).x * pow(blend,power) * strength;\n"
   "	}\n"
   "};\n"
   "struct TexCoordTextureBlendForce : Force{\n"
   "	samplerRECT texCoordsTexture;\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	Force force1;\n"
   "	\n"
   "	float strength;\n"
   "	float power;\n"
   "	\n"
   "	float2 scale;\n"
   "	float2 offset;\n"
   "	\n"
   "	int channel;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float4 texCoords = texRECT(texCoordsTexture, theTexID);\n"
   "		return \n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime) *\n"
   "			pow(texRECT(texture, texCoords.xy * scale + offset).x,power) * strength;\n"
   "	}\n"
   "};\n"
   "struct TimeForceBlend : Force{\n"
   "	Force force1;\n"
   "	Force force2;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float start;\n"
   "	float end;\n"
   "	\n"
   "	float power;\n"
   "	\n"
   "	samplerRECT blendInfos;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float4 timeInfo = texRECT(infoTexture, theTexID);\n"
   "		float4 blendInfo = texRECT(blendInfos, float2(timeInfo.w,0));\n"
   "		float time = timeInfo.x;\n"
   "		time -= start;\n"
   "		float timeBlend = clamp(time, 0, end - start) / (end - start);\n"
   "		\n"
   "		return lerp(\n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			force2.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			clamp(pow(timeBlend,power), blendInfo.r,blendInfo.g)\n"
   "		) * strength;\n"
   "	}\n"
   "};\n"
   "struct SaudiTimeForceBlend : Force{\n"
   "	Force force1;\n"
   "	Force force2;\n"
   "	Force force3;\n"
   "	Force force4;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float start;\n"
   "	float end;\n"
   "	\n"
   "	float power;\n"
   "	\n"
   "	samplerRECT blendInfos;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float4 timeInfo = texRECT(infoTexture, theTexID);\n"
   "		float4 blendInfo = texRECT(blendInfos, float2(timeInfo.w + 0.5,0.5));\n"
   "		float timeBlend = timeInfo.x / timeInfo.y;\n"
   "		//time -= start;\n"
   "		//float timeBlend = clamp(time, 0, end - start) / (end - start);\n"
   "		\n"
   "		return lerp(\n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime) +\n"
   "			force2.force(thePosition, theVelocity, theTexID, theDeltaTime) +\n"
   "			force3.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			force4.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			clamp(pow(timeBlend,power), blendInfo.r,blendInfo.g)\n"
   "		) * strength;\n"
   "	}\n"
   "};\n"
   "struct CombinedForce : Force{\n"
   "	Force forces[];\n"
   "	\n"
   "	float strength;\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 result = float3(0,0,0);\n"
   "		\n"
   "		for(int i = 0; i < forces.length;i++){\n"
   "		result += float3(1,0,0);\n"
   "			result += forces[i].force(thePosition, theVelocity, theTexID, theDeltaTime);\n"
   "		}\n"
   "		return result * strength;\n"
   "	}\n"
   "};\n"
   "struct StateSystem : Force{\n"
   "	Force forces[];\n"
   "	samplerRECT stateInfos;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 stateInfo = texRECT(stateInfos, theTexID);\n"
   "		\n"
   "		Force force1 = forces[(int)stateInfo.x];\n"
   "		Force force2 = forces[(int)stateInfo.y];\n"
   "		\n"
   "		return lerp(\n"
   "			force1.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			force2.force(thePosition, theVelocity, theTexID, theDeltaTime),\n"
   "			stateInfo.z\n"
   "		) * strength;\n"
   "	}\n"
   "};\n"
   "struct TargetForce : Force{\n"
   "	samplerRECT targetPositionTexture;\n"
   "	\n"
   "	float3 center;\n"
   "	float scale;\n"
   "	float strength;\n"
   "	float lookAhead;\n"
   "	float maxForce;\n"
   "	float nearDistance;\n"
   "	float nearMaxForce;\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "	\n"
   "		float4 targetInfos = texRECT (targetPositionTexture, theTexID);\n"
   "		float3 target = targetInfos.xyz * scale + center;\n"
   "		float targetStrength = targetInfos.w * strength;\n"
   "		\n"
   "		if(target.x == 0.0)return float3(0.0);\n"
   "		//float factor = (-dot(normalize(target - thePosition),normalize(theVelocity)) + 1) / 2;\n"
   "		float3 force = target - (thePosition + theVelocity * theDeltaTime * lookAhead * targetStrength);\n"
   "		\n"
   "		float distance = length(force);\n"
   "		if(nearMaxForce > 0 && distance < nearDistance && distance > nearMaxForce){\n"
   "			return force / distance * nearMaxForce * targetStrength;\n"
   "		}\n"
   "		if(maxForce > 0 && distance > maxForce){\n"
   "			return force / distance * maxForce * targetStrength;\n"
   "		}\n"
   "		return force * targetStrength;// / (theDeltaTime * 60);\n"
   "	}\n"
   "};\n"
   "struct MultiTargetForce : Force{\n"
   "	samplerRECT targetPositionTexture;\n"
   "	samplerRECT stateIDTexture;\n"
   "	samplerRECT stateInfoTexture;\n"
   "	\n"
   "	float3 center;\n"
   "	float strength;\n"
   "	float lookAhead;\n"
   "	float maxForce;\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "	\n"
   "		float4 stateIDs = texRECT(stateIDTexture, theTexID);\n"
   "		float4 stateInfos = texRECT(stateInfoTexture, theTexID);\n"
   "		\n"
   "		float blend = stateInfos.z;\n"
   "		\n"
   "		float4 target1 = float4(0.0);\n"
   "		\n"
   "		if(stateInfos.x < 0){\n"
   "			blend = 1.0;\n"
   "		} else {\n"
   "			target1.xyz = texRECT (targetPositionTexture, stateIDs.xy) + center;\n"
   "			target1.w = 1.0;\n"
   "		}\n"
   "		\n"
   "		float4 target2 = float4(0.0);\n"
   "		if(stateInfos.y < 0){\n"
   "			blend = 0.0;\n"
   "		} else {\n"
   "			target2.xyz = texRECT (targetPositionTexture, stateIDs.zw) + center;\n"
   "			target2.w = 1.0;\n"
   "		}\n"
   "		\n"
   "		float3 target = lerp(\n"
   "			target1.xyz,\n"
   "			target2.xyz,\n"
   "			blend\n"
   "		);\n"
   "		\n"
   "		//float factor = (-dot(normalize(target - thePosition),normalize(theVelocity)) + 1) / 2;\n"
   "		float3 force = target - (thePosition + theVelocity * theDeltaTime * lookAhead * strength);\n"
   "		\n"
   "		float distance = length(force);\n"
   "		if(maxForce > 0 && distance > maxForce)force = force / distance * maxForce;\n"
   "		\n"
   "		return force * strength * saturate(target1.w + target2.w);// / (theDeltaTime * 60);\n"
   "	}\n"
   "};\n"
   "struct NearestTargetForce : Force{\n"
   "	samplerRECT targetPositionTexture;\n"
   "	\n"
   "	float2 textureSize;\n"
   "	float2 textureScale;\n"
   "	float2 textureOffset;\n"
   "	\n"
   "	float targetTime;\n"
   "	\n"
   "	float strength;\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "	\n"
   "		float3 target = texRECT (targetPositionTexture, theTexID);\n"
   "		float myUseTarget = target.z > 0 && target.z < targetTime;\n"
   "		target = (target) * float3(textureScale,0) + float3(textureOffset,0);\n"
   "		float3 force = target - thePosition;\n"
   "	/*\n"
   "		float distance = length(force);\n"
   "		float goalLength = 2 * length(theVelocity);\n"
   "		if(distance > goalLength)force *= goalLength / distance;\n"
   "		*/	\n"
   "		force *= 1;\n"
   "		force -= theVelocity;\n"
   "		return force * strength / (theDeltaTime * 60) * myUseTarget;\n"
   "	}\n"
   "};\n"
   "struct Springs : Force{\n"
   "	samplerRECT[] idTextures;\n"
   "	samplerRECT[] infoTextures;\n"
   "	\n"
   "	float springConstant;\n"
   "	float strength;\n"
   "	\n"
   "	float3 springForce(float3 thePosition1, float3 thePosition2, float theRestLength, float theForceRestLength){\n"
   "		float3 delta = thePosition2 - thePosition1;\n"
   "		float deltalength = length(delta);\n"
   "		delta /= max(1,deltalength);\n"
   "		float springForce = (deltalength - theRestLength) * springConstant * 0.1 * (deltalength > theRestLength || theForceRestLength > 0);\n"
   "		return delta * springForce;\n"
   "	}\n"
   "	\n"
   "	// constrain a particle to be a fixed distance from another particle\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float3 force = 0;\n"
   "		\n"
   "		for(int i = 0; i < idTextures.length;i++){\n"
   "			int4 ids = texRECT(idTextures[i], theTexID);\n"
   "		\n"
   "			// get positions of neighbouring particles\n"
   "			float3 position1 = texRECT(positionTexture, ids.xy);\n"
   "			float3 position2 = texRECT(positionTexture, ids.zw);\n"
   "			\n"
   "			float4 infos = texRECT(infoTextures[i], theTexID);\n"
   "			float restLength1 = infos.x;\n"
   "			float restLength2 = infos.y;\n"
   "			float forceRestLength1 = infos.z;\n"
   "			float forceRestLength2 = infos.w;\n"
   "		\n"
   "			force += springForce(thePosition, position1, restLength1, forceRestLength1) * (ids.x >= 0);\n"
   "			force += springForce(thePosition, position2, restLength2, forceRestLength2) * (ids.z >= 0);\n"
   "			\n"
   "			//continue;\n"
   "		}\n"
   "		return force * strength;\n"
   "	}\n"
   "};\n"
   "struct DampedSprings : Force{\n"
   "	samplerRECT[] idTextures;\n"
   "	samplerRECT[] infoTextures;\n"
   "	\n"
   "	float restLength;\n"
   "	float springConstant;\n"
   "	float springDamping;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 springForce(float3 thePosition1, float3 thePosition2, float3 theVelocity1, float3 theVelocity2, float theRestLength, float theForceRestLength){\n"
   "		float3 deltaPosition = thePosition1 - thePosition2;\n"
   "        float3 deltaVelocity = theVelocity1 - theVelocity2;\n"
   "		\n"
   "		float myDistance = length(deltaPosition);\n"
   "		\n"
   "		deltaPosition /= max(1,myDistance);\n"
   "		//deltaPosition *= myDistance > 0;\n"
   "        float springForce = - (myDistance - theRestLength) * springConstant * (myDistance > theRestLength);\n"
   "            \n"
   "       	float dampingForce = -springDamping * dot(deltaPosition, deltaVelocity);\n"
   "        return deltaPosition * (springForce + dampingForce);\n"
   "	}\n"
   "	\n"
   "	// constrain a particle to be a fixed distance from another particle\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		\n"
   "		float3 force = 0;\n"
   "		\n"
   "		//for(int i = 0; i < idTextures.length;i++){\n"
   "			float4 ids = texRECT(idTextures[0], theTexID);\n"
   "		\n"
   "			// get positions of neighbouring particles\n"
   "			float3 position1 = texRECT(positionTexture, ids.xy);\n"
   "			float3 position2 = texRECT(positionTexture, ids.zw);\n"
   "			\n"
   "			// get velocities of neighbouring particles\n"
   "			float3 velocity1 = texRECT(velocityTexture, ids.xy);\n"
   "			float3 velocity2 = texRECT(velocityTexture, ids.zw);\n"
   "			\n"
   "			float4 infos = texRECT(infoTextures[0], theTexID);\n"
   "			float restLength1 = infos.x;\n"
   "			float restLength2 = infos.y;\n"
   "			float forceRestLength1 = infos.z;\n"
   "			float forceRestLength2 = infos.w;\n"
   "		\n"
   "			force = force + springForce(thePosition, position1, theVelocity, velocity1, restLength1, forceRestLength1) * (ids.x >= 0);\n"
   "			force = force + springForce(thePosition, position2, theVelocity, velocity2, restLength2, forceRestLength2) * (ids.z >= 0);\n"
   "		//}\n"
   "		return force * strength;\n"
   "	}\n"
   "	\n"
   "	\n"
   "};\n"
   "struct AnchoredSprings : Force{\n"
   "	samplerRECT anchorPositionTexture;\n"
   "	\n"
   "	float restLength;\n"
   "	float springConstant;\n"
   "	float springDamping;\n"
   "	\n"
   "	float strength;\n"
   "	\n"
   "	float3 springForce(float3 thePosition1, float3 thePosition2, float3 theVelocity1, float3 theVelocity2){\n"
   "		float3 deltaPosition = thePosition1 - thePosition2;\n"
   "        float3 deltaVelocity = theVelocity1 - theVelocity2;\n"
   "		\n"
   "		float myDistance = length(deltaPosition);\n"
   "		\n"
   "		deltaPosition /= max(1,myDistance);\n"
   "        float springForce = - (myDistance - restLength) * springConstant;\n"
   "            \n"
   "       	float dampingForce = -springDamping * dot(deltaPosition, deltaVelocity);\n"
   "        return deltaPosition * (springForce + dampingForce);\n"
   "	}\n"
   "	\n"
   "	float3 force(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime){\n"
   "		float4 anchor = texRECT(anchorPositionTexture, theTexID);\n"
   "		\n"
   "		if(anchor.w == 0)return float3(0,0,0);\n"
   "		return springForce(thePosition, anchor.xyz, theVelocity, float3(0,0,0)) * anchor.w * strength;\n"
   "	}\n"
   "};\n"
   "uniform Force forces[];\n"
   ;
