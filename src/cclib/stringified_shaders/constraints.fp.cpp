/* Generated file, do not edit! */

#include "constraints.fp.h"

char const* const constraints_fp = 
   "float3 bounceReflection(\n"
   "	float3 theVelocity, float3 theNormal, float thePlacement,\n"
   "	float theResilience, float theFriction, float theMinimalVelocity\n"
   "){\n"
   "	// Distibute velocity to normal and tangential contributions.\n"
   "	float normalContribution = dot(theVelocity, theNormal);\n"
   "	float3 vNormal = normalContribution * theNormal;\n"
   "	float3 vTangent = theVelocity - vNormal;\n"
   "	\n"
   "	if (thePlacement < 0){\n"
   "		// Get particle outside the collider as quickly as possible,\n"
   "		// either with original or reflected velocity.\n"
   "		\n"
   "		if (normalContribution <= 0.0){\n"
   "			return vTangent - vNormal;\n"
   "		} else {\n"
   "			return theVelocity;\n"
   "		}\n"
   "	} \n"
   "	\n"
   "	// Slow down particle with friction only if slower than minimal velocity.\n"
   "	if (length(theVelocity) < theMinimalVelocity)\n"
   "		theFriction = 1.0;\n"
   "	// Slowdown tangential movement with friction (in theory 1 - friction)\n"
   "	// and reflected normal movement via resilience factor.\n"
   "	return vTangent * theFriction - vNormal * theResilience;\n"
   "}\n"
   "float3 simpleReflection(float3 theVelocity, float3 theNormal, float theResilience){\n"
   "	return reflect(theVelocity, theNormal) * theResilience;\n"
   "}\n"
   "interface Constraint{\n"
   "	float3 constraint(float3 thePosition, float3 theVelocity, float2 theTexID, float theDeltaTime);\n"
   "};\n"
   "struct PlaneConstraint : Constraint{\n"
   "	float3 normal;\n"
   "	float constant;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID, float theDeltaTime){\n"
   "		float pseudoDistance = dot(normal, thePosition + theVelocity * theDeltaTime) - constant;\n"
   "		if (pseudoDistance < 0){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				normalize(normal), \n"
   "				pseudoDistance,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		return theVelocity;\n"
   "	}\n"
   "};\n"
   "struct FloorConstraint : Constraint{\n"
   "	float y;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID, float theDeltaTime){\n"
   "		if (thePosition.y + theVelocity.y * theDeltaTime < y){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(0, 1, 0), \n"
   "				thePosition.y - y,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		return theVelocity;\n"
   "	}\n"
   "};\n"
   "struct ZConstraint : Constraint{\n"
   "	float z;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID, float theDeltaTime){\n"
   "		if (thePosition.z + theVelocity.z * theDeltaTime < z){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(0, 0, 1), \n"
   "				thePosition.z - z,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		return theVelocity;\n"
   "	}\n"
   "};\n"
   "struct BoxConstraint : Constraint{\n"
   "	float3 minCorner;\n"
   "	float3 maxCorner;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID, float theDeltaTime){\n"
   "		float3 futurePosition = thePosition + theVelocity * theDeltaTime;\n"
   "		\n"
   "		if (futurePosition.x < minCorner.x){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(1, 0, 0), \n"
   "				thePosition.x - minCorner.x,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		if (futurePosition.y < minCorner.y){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(0, 1, 0), \n"
   "				thePosition.y - minCorner.y,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		if (futurePosition.z < minCorner.z){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(0, 0, 1), \n"
   "				thePosition.z - minCorner.z,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		\n"
   "		if (futurePosition.x > maxCorner.x){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(-1, 0, 0), \n"
   "				maxCorner.x - thePosition.x,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		if (futurePosition.y > maxCorner.y){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(0, -1, 0), \n"
   "				maxCorner.y - thePosition.y,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		if (futurePosition.z > maxCorner.z){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				float3(0, 0, -1), \n"
   "				maxCorner.z - thePosition.z,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		return theVelocity;\n"
   "	}\n"
   "};\n"
   "/*\n"
   " * constraint to let particles bounce of a sphere\n"
   " */\n"
   "struct SphereConstraint : Constraint{\n"
   "	float3 center;\n"
   "	float radius;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID,float theDeltaTime){\n"
   "		float3 delta = (thePosition + theVelocity * theDeltaTime) - center;\n"
   "		float dist = length(delta);\n"
   "		if (dist < radius){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				delta / dist,\n"
   "				distance(thePosition, center) - radius,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		return theVelocity;\n"
   "	}\n"
   "};\n"
   "/*\n"
   " * constraint to keep particles inside a sphere.\n"
   " */\n"
   "struct SphereInConstraint : Constraint{\n"
   "	float3 center;\n"
   "	float radius;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID,float theDeltaTime){\n"
   "		float3 delta = (thePosition + theVelocity * theDeltaTime) - center;\n"
   "		float dist = length(delta);\n"
   "		if (dist > radius){\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				delta / dist,\n"
   "				distance(thePosition, center) - radius,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		return theVelocity;\n"
   "	}\n"
   "};\n"
   "/*\n"
   " * terrain constraint that takes a heightmap texture to let particles bounce of it.\n"
   " * texture can be scaled and moved in all x,y and z direction to place it in the scene\n"
   " * correctly\n"
   " */\n"
   "struct TerrainConstraint : Constraint{\n"
   "	samplerRECT texture;\n"
   "	\n"
   "	float2 textureSize;\n"
   "	float3 scale;\n"
   "	float3 offset;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	float exponent;\n"
   "	\n"
   "	float terrainHeight(float2 terrainPos){\n"
   "		return pow((float)texRECT(texture, terrainPos),exponent);\n"
   "	}\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID, float theDeltaTime){\n"
   "		float3 fPosition = thePosition + theVelocity * theDeltaTime;\n"
   "		float2 terrainPos = fPosition.xz / scale.xz + offset.xz;\n"
   "		float height = terrainHeight(terrainPos);\n"
   "		if (fPosition.y < height * scale.y + offset.y){\n"
   "		\n"
   "			// Calculate normal vector.\n"
   "			float3 vertex0 = float3(0, height * scale.y, 0);\n"
   "			float3 vertex1 = float3(scale.x, terrainHeight(terrainPos + float2(1, 0)) * scale.y, 0);\n"
   "			float3 vertex2 = float3(0, terrainHeight(terrainPos + float2(0, 1)) * scale.y, scale.z);\n"
   "			\n"
   "			float3 normal = normalize(cross(vertex1 - vertex0, vertex2 - vertex0));\n"
   "			\n"
   "			if (normal.y < 0)\n"
   "				normal *= -1;\n"
   "	\n"
   "			// Check whether previous time step has collision already.\n"
   "			float2 terrainPosOld = thePosition.xz * (textureSize / scale.xz) + offset.xz;\n"
   "			float heightOld = terrainHeight(terrainPosOld) * scale.y + offset.y;\n"
   "			return bounceReflection(\n"
   "				theVelocity, \n"
   "				normal, \n"
   "				thePosition.y - heightOld,\n"
   "				resilience, \n"
   "				friction, \n"
   "				minimalVelocity\n"
   "			);\n"
   "		}\n"
   "		return theVelocity;\n"
   "	}\n"
   "};\n"
   "/*\n"
   "struct CableConstraint : Constraint{\n"
   "	samplerRECT id1Texture;\n"
   "	samplerRECT id2Texture;\n"
   "	\n"
   "	float maxLength;\n"
   "	\n"
   "	float resilience;\n"
   "	float friction;\n"
   "	float minimalVelocity;\n"
   "	\n"
   "	// constrain a particle to be a fixed distance from another particle\n"
   "	float3 constraint(float3 theVelocity, float3 thePosition, float2 theTexID, float theDeltaTime){\n"
   "	\n"
   "		float4 ids1 = texRECT(id1Texture, theTexID);\n"
   "		float4 ids2 = texRECT(id2Texture, theTexID);\n"
   "		\n"
   "		float3[4] positions;\n"
   "		\n"
   "		// get positions of neighbouring particles\n"
   "		positions[0] = texRECT(positionTexture, ids1.xy);\n"
   "		positions[1] = texRECT(positionTexture, ids1.zw);\n"
   "		positions[2] = texRECT(positionTexture, ids2.xy);\n"
   "		positions[3] = texRECT(positionTexture, ids2.zw);\n"
   "		\n"
   "		float3[4] normals;\n"
   "		\n"
   "		normal[0] = normalize(positions[0] - thePosition);\n"
   "		\n"
   "		float3[4] velocities;\n"
   "		\n"
   "		// get velocities of neighbouring particles\n"
   "		velocities[0] = texRECT(velocityTexture, ids1.xy);\n"
   "		velocities[1] = texRECT(velocityTexture, ids1.zw);\n"
   "		velocities[2] = texRECT(velocityTexture, ids2.xy);\n"
   "		velocities[3] = texRECT(velocityTexture, ids2.zw);\n"
   "		\n"
   "		float maxSeperation = 0;\n"
   "		float3 normal;\n"
   "		int index = -1;\n"
   "		\n"
   "		for(int i = 0; i < 4;i++){\n"
   "			normal = positions[i] - thePosition;\n"
   "			float seperation = length(normal);\n"
   "			if(seperation > maxSeperation){\n"
   "				maxSeperation = seperation;\n"
   "				index = i;\n"
   "			}\n"
   "		}\n"
   "		if(maxSeperation < maxLength)return theVelocity;\n"
   "		\n"
   "		return bounceReflection(\n"
   "			theVelocity - velocities[index], \n"
   "			normalize(normal), \n"
   "			maxLength - maxSeperation,\n"
   "			resilience, \n"
   "			friction, \n"
   "			minimalVelocity\n"
   "		);\n"
   "	}\n"
   "};\n"
   "*/\n"
   "uniform Constraint constraints[];\n"
   ;
